# This script was generated by crazy-complete.
# crazy-complete: A tool that creates robust and reliable autocompletion scripts for Bash, Fish and Zsh.
# For more information, visit: https://github.com/crazy-complete/crazy-complete

_ldc__prefix_compreply() {
  [[ "$cur" == *[$COMP_WORDBREAKS]* ]] && return

  local i prefix="$1"
  for ((i=0; i < ${#COMPREPLY[@]}; ++i)); do
    COMPREPLY[i]="$prefix${COMPREPLY[i]}"
  done
}

_ldc__dequote_words() {
  local word dequoted break_pos in_quotes

  words_dequoted=()

  for word in "${words[@]}"; do
    _ldc__dequote "$word" dequoted break_pos in_quotes
    words_dequoted+=("$dequoted")
  done
}

_ldc__dequote() {
  local in="$1" len=${#1} i=0 result='' ___break_pos=-1 ___in_quotes=0

  for ((; i < len; ++i)); do
    case "${in:i:1}" in
      "'")
        ___in_quotes=1
        for ((++i; i < len; ++i)); do
          [[ "${in:i:1}" == "'" ]] && { ___in_quotes=0; break; }
          result+="${in:i:1}"
        done;;
      '"')
        ___in_quotes=1
        for ((++i; i < len; ++i)); do
          [[ "${in:i:1}" == '"' ]] && { ___in_quotes=0; break; }

          if [[ "${in:i:1}" == '\' ]]; then
            result+="${in:$((++i)):1}"
          else
            result+="${in:i:1}"
          fi
        done;;
      '\')
        result+="${in:$((++i)):1}";;
      [$COMP_WORDBREAKS])
        result+="${in:i:1}"
        ___break_pos=${#result};;
      *)
        result+="${in:i:1}";;
    esac
  done

  local -n ___RESULT=$2
  local -n ___BREAK_POS=$3
  local -n ___IN_QUOTES=$4
  ___RESULT="$result"
  ___BREAK_POS=$___break_pos
  ___IN_QUOTES=$___in_quotes
}

_ldc__parse_commandline() {
  POSITIONALS=()
  END_OF_OPTIONS=0

  local cmd="root" argi arg i char trailing_chars VAR ARGS

  __find_option() {
    case "$2" in
      -d|--detach) VAR=OPT_detach; ARGS=0; return;;
      --docker-in-docker) VAR=OPT_docker_in_docker; ARGS=0; return;;
      --dry-run) VAR=OPT_dry_run; ARGS=0; return;;
      --extra-port-mappings) VAR=OPT_extra_port_mappings; ARGS=1; return;;
      -h|--help) VAR=OPT_help; ARGS=0; return;;
      -m|--mount-home) VAR=OPT_mount_home; ARGS=0; return;;
      -P|--password) VAR=OPT_password; ARGS=1; return;;
      -p|--port) VAR=OPT_port; ARGS=1; return;;
      -u|--user) VAR=OPT_user; ARGS=1; return;;
    esac
    return 1
  }

  __append_to_array() {
    local -n arr=$1
    arr+=("$2")
  }

  for ((argi=1; argi < cword; ++argi)); do
    arg="${words_dequoted[argi]}"

    case "$arg" in
      --)
        END_OF_OPTIONS=1
        POSITIONALS+=("${words_dequoted[@]:$((++argi))}")
        return;;
      --*=*)
        if __find_option "$cmd" "${arg%%=*}"
        then __append_to_array "$VAR" "${arg#*=}"
        fi;;
      --*)
        if __find_option "$cmd" "$arg"; then
          if [[ "$ARGS" == 1 ]]
          then __append_to_array "$VAR" "${words_dequoted[++argi]}"
          else __append_to_array "$VAR" "_OPT_ISSET_"
          fi
        fi;;
      -?*) # ignore '-'

        for ((i=1; i < ${#arg}; ++i)); do
          char="${arg:$i:1}"
          trailing_chars="${arg:$((i + 1))}"

          if __find_option "$cmd" "-$char"; then
            if [[ "$ARGS" == 1 ]]; then
              if [[ -n "$trailing_chars" ]]
              then __append_to_array "$VAR" "$trailing_chars"
              else __append_to_array "$VAR" "${words_dequoted[++argi]}"
              fi
              break;
            else
              __append_to_array "$VAR" "_OPT_ISSET_"
            fi
          fi
        done
        ;;
      *)
        POSITIONALS+=("$arg")
        ;;
    esac
  done

  for ((; argi <= cword; ++argi)); do
    case "${words_dequoted[argi]}" in
      -?*);;
      *) POSITIONALS+=("${words_dequoted[argi]}");;
    esac
  done
}

_ldc() {
  local cur prev words cword split words_dequoted
  _init_completion -n =: || return
  _ldc__dequote_words

  local END_OF_OPTIONS POSITIONALS
  local -a OPT_detach OPT_docker_in_docker OPT_dry_run OPT_extra_port_mappings
  local -a OPT_help OPT_mount_home OPT_password OPT_port OPT_user
  _ldc__parse_commandline

  __complete_option() {
    local opt="$1" cur="$2" ret=0

    case "$opt" in
      -@(-@(extra-port-mappings|p@(assword|ort)|user)|P|p|u));;
      *) ret=1;;
    esac

    return $ret
  }

  case "$prev" in
    --*) __complete_option "$prev" "$cur" && return 0;;
    -*([dhm])[Ppu])
         __complete_option "-${prev: -1}" "$cur" && return 0;;
  esac

  case "$cur" in
    --*=*)
      __complete_option "${cur%%=*}" "${cur#*=}" && return 0;;
    --*);;
    -*([dhm])[Ppu]*)
      local i
      for ((i=2; i <= ${#cur}; ++i)); do
        local pre="${cur:0:$i}" value="${cur:$i}"
        __complete_option "-${pre: -1}" "$value" && {
          _ldc__prefix_compreply "$pre"
          return 0
        }
      done;;
  esac

  if (( ! END_OF_OPTIONS )) && [[ "$cur" = -* ]]; then
    local -a opts
    (( ! ${#OPT_detach[@]} )) && opts+=(-d --detach)
    (( ! ${#OPT_docker_in_docker[@]} )) && opts+=(--docker-in-docker)
    (( ! ${#OPT_dry_run[@]} )) && opts+=(--dry-run)
    (( ! ${#OPT_extra_port_mappings[@]} )) && opts+=(--extra-port-mappings=)
    (( ! ${#OPT_help[@]} )) && opts+=(-h --help)
    (( ! ${#OPT_mount_home[@]} )) && opts+=(-m --mount-home)
    (( ! ${#OPT_password[@]} )) && opts+=(-P --password=)
    (( ! ${#OPT_port[@]} )) && opts+=(-p --port=)
    (( ! ${#OPT_user[@]} )) && opts+=(-u --user=)
    COMPREPLY+=($(compgen -W "${opts[*]}" -- "$cur"))
    [[ ${COMPREPLY-} == *= ]] && compopt -o nospace
    return 1
  fi

  (( ${#POSITIONALS[@]} == 1 )) && {
    COMPREPLY=($(compgen -W 'dclong/jupyterhub-ds dclong/vscode-server' -- "$cur"))
    return 0;
  }

  return 1
}

complete -F _ldc ldc

# vim: ft=sh ts=2 sts=2 sw=2 et
